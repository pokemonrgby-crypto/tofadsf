<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI 캐릭터 대전 시뮬레이터</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet"/>
  <style>
    body{font-family:'Noto Sans KR',sans-serif;background:#111827}
    .glass-card{background:rgba(255,255,255,.05);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.1)}
    .progress-bar-container{background-color:rgba(255,255,255,.1);border-radius:9999px;overflow:hidden;height:8px}
    .progress-bar{height:100%;transition:width .5s ease-in-out;border-radius:9999px}
    .char1-bar{background-color:#3b82f6}.char2-bar{background-color:#ef4444}
    .gradient-text{background:linear-gradient(to right,#4f46e5,#ec4899);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
    .score-slider-track{height:10px;background:linear-gradient(to right,#3b82f6,#8b5cf6,#d946ef,#f43f5e,#ef4444);border-radius:5px}
    .score-slider-thumb{width:24px;height:24px;background:#fff;border-radius:50%;border:2px solid #111827;box-shadow:0 0 10px rgba(0,0,0,.5);position:absolute;top:50%;transform:translate(-50%,-50%);transition:left .5s ease-in-out}
    textarea{resize:vertical}
    .pill{display:inline-block;padding:.15rem .5rem;border:1px solid rgba(255,255,255,.18);border-radius:9999px;font-size:.75rem}
    .crit-row{display:flex;align-items:center;gap:.5rem}
    .crit-name{min-width:7.5rem}
    .fade-in{animation:fade .4s ease}
    @keyframes fade{from{opacity:0;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  </style>
</head>
<body class="text-white antialiased">
<div class="container mx-auto p-4 md:p-8">
  <header class="text-center mb-10">
    <h1 class="text-4xl md:text-5xl font-bold gradient-text">AI 캐릭터 대전 시뮬레이터</h1>
    <p class="text-gray-400 mt-2">강한 쪽은 덜 너프, 약한 쪽은 확정 파훼·약화. 조정 후 텍스트로 배틀까지!</p>
  </header>

  <main>
    <!-- API Key -->
    <div class="glass-card rounded-2xl p-6 mb-8 max-w-2xl mx-auto">
      <label for="api-key-input" class="block text-sm font-medium text-gray-300 mb-2">Gemini API 키</label>
      <input type="password" id="api-key-input" class="w-full bg-gray-900/50 border border-gray-700 rounded-lg px-3 py-2 focus:ring-2 focus:ring-purple-500 focus:outline-none transition" placeholder="API 키를 여기에 입력하세요">
      <div class="flex items-center justify-between mt-2">
        <p class="text-xs text-gray-500">API 키는 브라우저에만 저장되며, 서버로 전송되지 않습니다.</p>
        <button id="save-key" class="text-xs pill hover:bg-white/10">키 저장</button>
      </div>
    </div>

    <!-- Inputs -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
      <div class="glass-card rounded-2xl p-6 space-y-4">
        <h2 class="text-2xl font-bold text-blue-400">캐릭터 1</h2>
        <div>
          <label for="char1-name" class="block text-sm font-medium text-gray-300 mb-1">이름</label>
          <input type="text" id="char1-name" class="w-full bg-gray-900/50 border border-gray-700 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:outline-none transition" placeholder="예: 시리우스">
        </div>
        <div>
          <label for="char1-narrative" class="block text-sm font-medium text-gray-300 mb-1">서사 (배경, 성격 등)</label>
          <textarea id="char1-narrative" rows="8" class="w-full bg-gray-900/50 border border-gray-700 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:outline-none transition" placeholder="캐릭터의 배경 이야기, 성격, 주요 사건 등을 서술해주세요."></textarea>
        </div>
        <div>
          <label for="char1-skills" class="block text-sm font-medium text-gray-300 mb-1">스킬</label>
          <textarea id="char1-skills" rows="6" class="w-full bg-gray-900/50 border border-gray-700 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:outline-none transition" placeholder="캐릭터가 사용하는 능력이나 기술을 설명해주세요."></textarea>
        </div>
      </div>

      <div class="glass-card rounded-2xl p-6 space-y-4">
        <h2 class="text-2xl font-bold text-red-400">캐릭터 2</h2>
        <div>
          <label for="char2-name" class="block text-sm font-medium text-gray-300 mb-1">이름</label>
          <input type="text" id="char2-name" class="w-full bg-gray-900/50 border border-gray-700 rounded-lg px-3 py-2 focus:ring-2 focus:ring-red-500 focus:outline-none transition" placeholder="예: 녹스">
        </div>
        <div>
          <label for="char2-narrative" class="block text-sm font-medium text-gray-300 mb-1">서사 (배경, 성격 등)</label>
          <textarea id="char2-narrative" rows="8" class="w-full bg-gray-900/50 border border-gray-700 rounded-lg px-3 py-2 focus:ring-2 focus:ring-red-500 focus:outline-none transition" placeholder="캐릭터의 배경 이야기, 성격, 주요 사건 등을 서술해주세요."></textarea>
        </div>
        <div>
          <label for="char2-skills" class="block text-sm font-medium text-gray-300 mb-1">스킬</label>
          <textarea id="char2-skills" rows="6" class="w-full bg-gray-900/50 border border-gray-700 rounded-lg px-3 py-2 focus:ring-2 focus:ring-red-500 focus:outline-none transition" placeholder="캐릭터가 사용하는 능력이나 기술을 설명해주세요."></textarea>
        </div>
      </div>
    </div>

    <!-- Action -->
    <div class="text-center space-x-2">
      <button id="analyze-btn" class="bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-bold py-3 px-8 rounded-full text-lg transition-all duration-300 transform hover:scale-105 shadow-lg shadow-purple-500/20 disabled:opacity-50 disabled:cursor-wait">
        <span id="btn-text">강함 분석 및 밸런스 조정</span>
        <div id="loading-spinner" class="hidden w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin mx-auto"></div>
      </button>
      <button id="battle-btn" class="hidden bg-gradient-to-r from-emerald-600 to-teal-600 hover:from-emerald-700 hover:to-teal-700 text-white font-bold py-3 px-8 rounded-full text-lg transition-all duration-300 transform hover:scale-105 shadow-lg shadow-emerald-500/20 disabled:opacity-50 disabled:cursor-wait">
        <span id="battle-btn-text">너프 적용 후 배틀 실행</span>
        <div id="battle-loading" class="hidden w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin mx-auto"></div>
      </button>
    </div>

    <!-- Results -->
    <div id="results" class="mt-12 hidden fade-in">
      <!-- Overall -->
      <div class="glass-card rounded-2xl p-6 mb-8">
        <h3 class="text-2xl font-bold text-center mb-4">종합 상대 강함</h3>
        <div class="relative w-full h-10 flex items-center">
          <div class="score-slider-track w-full"></div>
          <div id="score-thumb" class="score-slider-thumb"></div>
          <div class="absolute w-full flex justify-between top-full mt-2 text-sm text-gray-400">
            <span class="font-bold text-blue-400">캐릭터 1 우세</span>
            <span class="font-bold">동등</span>
            <span class="font-bold text-red-400">캐릭터 2 우세</span>
          </div>
        </div>
        <p id="score-text" class="text-center text-3xl font-bold mt-10"></p>
        <p id="score-comment" class="text-center text-gray-300 mt-2"></p>
      </div>

      <!-- Details -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
        <div class="glass-card rounded-2xl p-6">
          <h3 class="text-xl font-bold text-blue-400 mb-4" id="char1-result-name">캐릭터 1 분석</h3>
          <div id="char1-analysis" class="space-y-3"></div>
        </div>
        <div class="glass-card rounded-2xl p-6">
          <h3 class="text-xl font-bold text-red-400 mb-4" id="char2-result-name">캐릭터 2 분석</h3>
          <div id="char2-analysis" class="space-y-3"></div>
        </div>
      </div>

      <!-- Nerf -->
      <div class="mb-10">
        <h3 class="text-2xl font-bold text-center mb-6">AI 기반 밸런스 조정 제안</h3>
        <p class="text-center text-gray-400 mb-6 -mt-4 text-sm">강한 쪽은 유지 강조, 약한 쪽은 확정 파훼·약화로 재서술합니다.</p>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
          <div class="glass-card rounded-2xl p-6">
            <h4 class="text-xl font-bold text-blue-400 mb-3" id="char1-nerfed-name">캐릭터 1 조정안</h4>
            <p id="char1-nerfed" class="text-gray-300 whitespace-pre-wrap"></p>
          </div>
          <div class="glass-card rounded-2xl p-6">
            <h4 class="text-xl font-bold text-red-400 mb-3" id="char2-nerfed-name">캐릭터 2 조정안</h4>
            <p id="char2-nerfed" class="text-gray-300 whitespace-pre-wrap"></p>
          </div>
        </div>
      </div>

      <!-- Battle -->
      <div id="battle-section" class="hidden">
        <h3 class="text-2xl font-bold text-center mb-4">너프 적용 후 배틀 결과</h3>
        <div class="glass-card rounded-2xl p-6 mb-6">
          <div class="grid md:grid-cols-3 gap-4 items-center">
            <div class="text-center">
              <div class="text-sm text-gray-400">승자</div>
              <div id="battle-winner" class="text-xl font-bold"></div>
            </div>
            <div class="text-center">
              <div class="text-sm text-gray-400">판정 신뢰도</div>
              <div id="battle-confidence" class="text-xl font-bold"></div>
            </div>
            <div class="text-center">
              <div class="text-sm text-gray-400">타이틀</div>
              <div id="battle-title" class="text-xl font-bold"></div>
            </div>
          </div>
        </div>
        <div class="glass-card rounded-2xl p-6 mb-6">
          <h4 class="font-bold mb-2">하이라이트</h4>
          <ul id="battle-highlights" class="list-disc list-inside text-gray-300 space-y-1"></ul>
        </div>
        <div class="glass-card rounded-2xl p-6">
          <h4 class="font-bold mb-2">배틀 로그</h4>
          <pre id="battle-log" class="text-gray-200 whitespace-pre-wrap mono text-sm leading-relaxed"></pre>
        </div>
      </div>
    </div>
  </main>
</div>

<script>
/* ========== DOM ========== */
const analyzeBtn = document.getElementById('analyze-btn');
const btnText = document.getElementById('btn-text');
const loadingSpinner = document.getElementById('loading-spinner');
const resultsSection = document.getElementById('results');
const apiKeyInput = document.getElementById('api-key-input');
const saveKeyBtn = document.getElementById('save-key');
const battleBtn = document.getElementById('battle-btn');
const battleBtnText = document.getElementById('battle-btn-text');
const battleLoading = document.getElementById('battle-loading');

const CRITERIA = [
  '논리성','무결성','재미성','완성성','매력성','서사적 역할',
  '초월성','노련함','물리적 강함','정신적 강함','마법적 강함','개념적 강함','잠재적 강함'
];
const BATTLE_CRITERIA = ['물리적 강함','정신적 강함','마법적 강함','개념적 강함','잠재적 강함','초월성','노련함','완성성','매력성','서사적 역할'];

/* 너프 후 텍스트 저장용 */
let ADJUSTED_TEXT = { c1:'', c2:'', n1:'', n2:'' };

/* ========== System Prompts ========== */
const EVALUATION_SYSTEM_PROMPT = `
당신은 13명의 전문 캐릭터 심사위원단입니다. 각 심사위원은 다음 기준 중 하나를 맡아 평가합니다: ${CRITERIA.join(', ')}.

- 논리성: 상충 설명·조건부 절대승리·자기모순은 강력 감점. 요약/복선은 과한 감점 금지.
- 무결성: 메타/프롬프트 인식, "상대는 반드시 패배", 아이템 등급(normal~omega) 언급·재정의는 강력 감점.
  *채점 정책*: 무결성은 기본 0점을 기준으로 하되, 노출된 텍스트에 메타/위반 정황이 전혀 없고 세계 내 자연스럽다면 100점, 그 외 대다수는 0~60점으로 보수적으로 책정.
- 재미성: 일방적/단순 능력(무조건 승리, 조건부 절대승리 등)은 대폭 감점.
- 완성성: 배경·성격·외형의 구체성/일관성.
- 매력성: 대중적/캐릭터성 매력.
- 서사적 역할: 플롯 견인 잠재력.
- 초월성: 규칙 초월 정도(높을수록 카운터 무시 가능).
- 노련함: 전투경험·지략·판단·환경활용.
- 물리/정신/마법/개념/잠재 강함: 각 영역 영향력/내성/규모/성장.

반드시 아래 JSON 한 개만 출력:
{"evaluations":[
  {"criterion":"논리성","score":0,"comment":"코멘트"},
  {"criterion":"무결성","score":100,"comment":"코멘트"},
  ... 총 13개 항목
]}
`.trim();

/* ▼▼▼ 새 너프 정책 */
const NERF_SYSTEM_PROMPT = `
당신은 세계관 밸런스 디자이너입니다. 아래 "강제 정책"을 엄격히 지키세요.

강제 정책:
- 상대보다 스탯이 높을수록 너프를 최소화(핵심 능력 유지, 표현만 구체화).
- 상대보다 스탯이 낮을수록 확정형으로 약화·파훼·무력화가 서사에 반영되어야 함.
- "가능, 수 있다, 일 수도, ~일지 모른다" 등의 **추측/가능성 표현 금지**. **확정형(된다/파훼된다/약화된다/무력화된다/봉인된다)**만 사용.
- "절대 승리/모든 것을 무효화/항상 승리" 같은 메타 절대표현은 금지(무결성 위배 방지).
- 쿨타임/자원소모/카운터 같은 턴제 규칙을 새로 도입하지 말 것.

출력은 JSON 한 개만:
{
  "character1_adjusted": "...",
  "character2_adjusted": "..."
}
`.trim();

/* 배틀도 확정 서술만 따르게 */
const BATTLE_SYSTEM_PROMPT = `
역할: 너는 두 캐릭터의 단일 전투 라운드를 한국어로 서술하는 AI다.
출력: JSON 한 개만. 다른 텍스트 금지.
형식:
{
  "title": "짧은 전투 제목",
  "winner": "char1|char2",
  "confidence": 0.0~1.0,
  "highlights": ["불릿 4~6개"],
  "log": "문단 5~8개, 각 문단은 \\n\\n 로 구분. HTML 금지."
}
규칙:
- 입력의 "조정된(너프된) 텍스트"의 **확정 파훼/약화 관계**를 그대로 적용한다.
- 가능성/추측 표현 사용 금지. 결과는 확정 서술로 기술한다.
- "절대 승리/모든 것을 무효화" 같은 표현은 쓰지 않는다.
- 무승부는 금지한다.
`.trim();

/* ========== Events ========== */
window.addEventListener('DOMContentLoaded', () => {
  const saved = localStorage.getItem('gemini_key');
  if (saved) apiKeyInput.value = saved;
});
saveKeyBtn.addEventListener('click', () => {
  localStorage.setItem('gemini_key', apiKeyInput.value.trim());
  saveKeyBtn.textContent = '저장됨';
  setTimeout(()=> saveKeyBtn.textContent='키 저장', 1200);
});
analyzeBtn.addEventListener('click', handleAnalysis);
battleBtn.addEventListener('click', handleBattle);

/* ========== Main Flow ========== */
async function handleAnalysis(){
  const apiKey = apiKeyInput.value.trim();
  if(!apiKey){ alert('Gemini API 키를 입력해주세요.'); apiKeyInput.focus(); return; }

  const char1 = {
    name: document.getElementById('char1-name').value.trim() || '캐릭터 1',
    narrative: document.getElementById('char1-narrative').value.trim(),
    skills: document.getElementById('char1-skills').value.trim()
  };
  const char2 = {
    name: document.getElementById('char2-name').value.trim() || '캐릭터 2',
    narrative: document.getElementById('char2-narrative').value.trim(),
    skills: document.getElementById('char2-skills').value.trim()
  };
  if(!char1.narrative || !char1.skills || !char2.narrative || !char2.skills){
    alert('모든 캐릭터 정보를 입력해주세요.');
    return;
  }
  setLoading(true);
  try{
    const [eval1, eval2] = await Promise.all([
      evaluateCharacter(char1, apiKey),
      evaluateCharacter(char2, apiKey)
    ]);
    if(!eval1 || !eval2) throw new Error('캐릭터 평가 중 오류가 발생했습니다.');

    const { score1, score2, finalRelativeScore, buckets1, buckets2, finals1, finals2 } =
      calculateFinalScores(eval1, eval2);

    const nerfed = await getNerfedDescriptions(char1, char2, score1, score2, eval1, eval2, apiKey, buckets1, buckets2);

    displayResults(char1, char2, eval1, eval2, finalRelativeScore, nerfed, buckets1, buckets2, finals1, finals2);
    battleBtn.classList.remove('hidden');
    ADJUSTED_TEXT = { c1: nerfed.c1, c2: nerfed.c2, n1: char1.name, n2: char2.name };
  }catch(e){
    console.error(e);
    alert(`오류가 발생했습니다: ${e.message}`);
  }finally{
    setLoading(false);
  }
}

async function handleBattle(){
  const apiKey = apiKeyInput.value.trim();
  if(!apiKey){ alert('Gemini API 키를 입력해주세요.'); return; }
  if(!ADJUSTED_TEXT.c1 || !ADJUSTED_TEXT.c2){
    alert('먼저 밸런스 조정을 실행해주세요.');
    return;
  }
  setBattleLoading(true);
  try{
    const userPrompt = `
### 캐릭터 1(조정 후)
이름: ${ADJUSTED_TEXT.n1}
설명: ${ADJUSTED_TEXT.c1}

### 캐릭터 2(조정 후)
이름: ${ADJUSTED_TEXT.n2}
설명: ${ADJUSTED_TEXT.c2}
`.trim();

    const res = await callGemini(BATTLE_SYSTEM_PROMPT, userPrompt, apiKey);
    const title = String(res?.title || '').trim();
    const winner = String(res?.winner || 'draw').trim();
    const confidence = Math.max(0, Math.min(1, Number(res?.confidence || 0.5)));
    const highlights = Array.isArray(res?.highlights) ? res.highlights : [];
    const log = String(res?.log || '').trim();

    document.getElementById('battle-title').textContent = title || '무제';
    document.getElementById('battle-winner').textContent =
      winner === 'char1' ? ADJUSTED_TEXT.n1 : winner === 'char2' ? ADJUSTED_TEXT.n2 : '무승부';
    document.getElementById('battle-confidence').textContent = `${Math.round(confidence*100)}%`;
    const ul = document.getElementById('battle-highlights');
    ul.innerHTML = '';
    highlights.forEach(h=>{
      const li = document.createElement('li'); li.textContent = h; ul.appendChild(li);
    });
    document.getElementById('battle-log').textContent = log;
    document.getElementById('battle-section').classList.remove('hidden');
    document.getElementById('battle-section').scrollIntoView({ behavior:'smooth' });
  }catch(e){
    console.error(e);
    alert(`배틀 생성 중 오류: ${e.message}`);
  }finally{
    setBattleLoading(false);
  }
}

/* ========== API ========== */
async function callGemini(systemPrompt, userPrompt, apiKey){
  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${encodeURIComponent(apiKey)}`;
  const payload = {
    systemInstruction: { parts: [{ text: systemPrompt }] },
    contents: [{ role:'user', parts: [{ text: userPrompt }] }],
    generationConfig: { responseMimeType: "application/json", temperature: 0.2 },
    safetySettings: [
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" }
    ]
  };
  const res = await fetch(API_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
  if(!res.ok){
    const txt = await res.text().catch(()=> '');
    throw new Error(`API Error: ${res.status} ${txt}`);
  }
  const data = await res.json();
  const text = data?.candidates?.[0]?.content?.parts?.[0]?.text;
  if(!text) throw new Error('API 응답에서 텍스트를 찾을 수 없습니다.');
  return parseJsonSafe(text);
}

/* Robust JSON parse */
function parseJsonSafe(t){
  if(!t) return null;
  try{
    let s = String(t).trim();
    s = s.replace(/^```(?:json)?\s*/i, '').replace(/```$/,'').trim();
    const fb = s.indexOf('{'), lb = s.lastIndexOf('}');
    if(fb !== -1 && lb > fb) s = s.slice(fb, lb+1);
    s = s.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm,'$1');
    s = s.replace(/,\s*([}\]])/g,'$1');
    return JSON.parse(s);
  }catch(e){
    console.warn('parseJsonSafe 실패, 원문 미리보기:', String(t).slice(0,400));
    return null;
  }
}

/* ========== Evaluation ========== */
async function evaluateCharacter(char, apiKey){
  const userPrompt = `
### 캐릭터 이름
${char.name}

### 내러티브
${char.narrative}

### 스킬
${char.skills}
`.trim();

  const json = await callGemini(EVALUATION_SYSTEM_PROMPT, userPrompt, apiKey);
  const out = new Map();
  (json?.evaluations || []).forEach(e=>{
    out.set(String(e.criterion), {
      score: Math.max(0, Math.min(100, Number(e.score) || 0)),
      comment: String(e.comment || '').trim()
    });
  });
  CRITERIA.forEach(c => {
    if(!out.has(c)) out.set(c, { score:50, comment:'AI 응답 누락' });
  });
  return out;
}

/* ========== Relative Score / Buckets ========== */
function calculateFinalScores(map1, map2){
  const sCurve = (score, k=0.15, x0=50)=> 1/(1+Math.exp(-k*(score-x0)));

  const WEIGHTS = {
    '물리적 강함':1.0,'정신적 강함':1.0,'마법적 강함':1.0,'개념적 강함':1.3,
    '잠재적 강함':0.8,'초월성':1.3,'노련함':0.7,'완성성':0.5,'매력성':0.3,'서사적 역할':0.5
  };

  function finalize(map){
    const logic = map.get('논리성')?.score ?? 100;
    const fun   = map.get('재미성')?.score ?? 100;
    const integ = map.get('무결성')?.score ?? 100;
    const comp  = map.get('완성성')?.score ?? 100;

    const eff = sCurve(logic) * sCurve(fun);
    const integPenalty = Math.max(0, 100 - integ) * 1.2;

    const result = new Map();
    for(const c of BATTLE_CRITERIA){
      let base = map.get(c)?.score ?? 50;
      if(c !== '노련함' && c !== '매력성') base = Math.round(base * eff);
      if(c === '잠재적 강함') base = Math.round(base * (comp/100));
      base = Math.max(0, base - integPenalty);
      result.set(c, base);
    }
    const globalDampen = (map.get('논리성')?.score ?? 100) < 40 ? 0.6 : 1.0;
    for(const k of result.keys()){
      result.set(k, Math.round(result.get(k) * globalDampen));
    }
    return { finals: result };
  }

  const A = finalize(map1);
  const B = finalize(map2);

  // 오버파워 캡 ±40
  for(const c of BATTLE_CRITERIA){
    let a = A.finals.get(c)||0, b = B.finals.get(c)||0;
    if(a - b > 40) a = b + 40;
    if(b - a > 40) b = a + 40;
    A.finals.set(c, a); B.finals.set(c, b);
  }

  // 상대성: tanh((b-a)/18)  →  +는 캐2 우세, –는 캐1 우세
  let num = 0, den = 0;
  for(const c of BATTLE_CRITERIA){
    const w = WEIGHTS[c] ?? 1;
    const a = A.finals.get(c)||0;
    const b = B.finals.get(c)||0;
    const r = Math.tanh((b - a) / 18);
    num += w * r;
    den += w;
  }
  const finalRelativeScore = Math.max(-100, Math.min(100, 100 * (num/den)));

  const buckets1 = bucketizePerCriterion(A.finals, B.finals, true);
  const buckets2 = bucketizePerCriterion(A.finals, B.finals, false);

  const sum = m => Array.from(m.values()).reduce((a,b)=>a+b,0);
  const score1 = sum(A.finals), score2 = sum(B.finals);

  return { score1, score2, finalRelativeScore, buckets1, buckets2, finals1: A.finals, finals2: B.finals };
}

function bucketizePerCriterion(Amap, Bmap, forA=true){
  const out = {};
  for(const c of BATTLE_CRITERIA){
    const a = Amap.get(c)||0, b = Bmap.get(c)||0;
    const diff = (forA ? a-b : b-a);
    let bucket, text;
    if(diff >= 35){ bucket = 100; text='압도적 우세'; }
    else if(diff >= 15){ bucket = 75; text='우세'; }
    else if(diff > -15){ bucket = 50; text='비슷함'; }
    else if(diff > -35){ bucket = 25; text='열세'; }
    else { bucket = 0; text='압도적 열세'; }
    out[c] = { bucket, text, self: forA ? a : b, opp: forA ? b : a, diff: (forA? a-b : b-a) };
  }
  return out;
}

/* ========== Nerf Constraints & Deterministic Post-process ========== */
function buildNerfConstraints(b1, b2){
  const lines = [];
  lines.push('정책: 강한 쪽(버킷 75/100)은 핵심 유지. 약한 쪽(버킷 0/25)은 확정 파훼/약화로 재서술.');
  lines.push('가능성/추측 표현 금지. 확정 표현만 사용(된다/파훼된다/약화된다/무력화된다/봉인된다).');
  lines.push('절대 승리/모든 것을 무효화/항상 승리 같은 메타 절대표현 금지.');

  const addPair = (whoStrong, whoWeak, strongBuckets, weakBuckets) => {
    for(const [c, sInfo] of Object.entries(strongBuckets)){
      const wInfo = weakBuckets[c];
      if(!wInfo) continue;
      if((sInfo.bucket>=75) && (wInfo.bucket<=25)){
        lines.push(`- ${whoStrong}의 「${c}」는 **유지**된다. 핵심 성능 하향 금지, 과장된 문구만 정제.`);
        lines.push(`- ${whoWeak}의 「${c}」는 ${whoStrong}의 같은 항목에 **파훼된다/약화된다/무력화된다** 중 하나로 확정 서술.`);
      } else if(sInfo.bucket>=50 && wInfo.bucket<=25){
        lines.push(`- ${whoWeak}의 「${c}」는 서사상 **약화된다**(효과 범위·명중·정밀·집중 중 최소 한 부분이 상시 약화됨).`);
      }
    }
  };
  addPair('캐릭터 1','캐릭터 2', b1, b2);
  addPair('캐릭터 2','캐릭터 1', b2, b1);

  // 비슷하면 양측 유지 지시
  for(const [c, info] of Object.entries(b1)){
    const j = b2[c];
    if(j && info.bucket===50 && j.bucket===50){
      lines.push(`- 「${c}」는 양측 모두 **유지**된다. 불필요한 약화 금지, 설명만 간결화.`);
    }
  }
  lines.push('문장 끝은 모두 확정형 어미로 마무리한다.');
  return lines.join('\n');
}

function enforceDeterministicLanguage(s){
  if(!s) return s;
  let out = String(s);
  out = out.replace(/할 수 있다/g, '한다');
  out = out.replace(/될 수 있다/g, '된다');
  out = out.replace(/일 수 있다/g, '이다');
  out = out.replace(/수도 있다/g, '한다');
  out = out.replace(/가능성/g, '사실');
  out = out.replace(/가능하다/g, '된다');
  out = out.replace(/가능합니다/g, '됩니다');
  out = out.replace(/일지도 모른다|일지도 모릅니다|할지도 모른다|할지도 모릅니다/g, '한다');
  out = out.replace(/경우가 있다/g, '발생한다');
  out = out.replace(/경향이 있다/g, '그렇다');
  out = out.replace(/모든 것을 ?(무효화|무시)/g, '상대의 기술을 파훼');
  out = out.replace(/항상 승리/g, '우위를 점한다');
  return out.trim();
}

/* 객체/배열을 문자열로 */
function normalizeAdjustedText(v){
  if(v == null) return '';
  if(typeof v === 'string') return v;
  if(Array.isArray(v)) return v.map(normalizeAdjustedText).join('\n\n');
  if(typeof v === 'object'){
    if(typeof v.text === 'string') return v.text;
    const pref = ['summary','narrative','skills','changes','adjustments','desc','description','result'];
    const parts = [];
    for(const k of pref){ if(v[k]) parts.push(`■ ${k}: ${normalizeAdjustedText(v[k])}`); }
    if(parts.length === 0){
      for(const k of Object.keys(v)){ parts.push(`■ ${k}: ${normalizeAdjustedText(v[k])}`); }
    }
    return parts.join('\n');
  }
  return String(v);
}

/* ========== Nerf Generation ========== */
async function getNerfedDescriptions(char1, char2, score1, score2, eval1, eval2, apiKey, buckets1, buckets2){
  const constraints = buildNerfConstraints(buckets1, buckets2);

  const payload = `
### 캐릭터 1
이름: ${char1.name}
내러티브: ${char1.narrative}
스킬: ${char1.skills}

### 캐릭터 2
이름: ${char2.name}
내러티브: ${char2.narrative}
스킬: ${char2.skills}

### 강제 제약(강한 쪽 유지 / 약한 쪽 확정 파훼·약화)
${constraints}
`.trim();

  const json = await callGemini(NERF_SYSTEM_PROMPT, payload, apiKey);
  const c1Raw = json?.character1_adjusted ?? '';
  const c2Raw = json?.character2_adjusted ?? '';
  const c1Text = enforceDeterministicLanguage(normalizeAdjustedText(c1Raw));
  const c2Text = enforceDeterministicLanguage(normalizeAdjustedText(c2Raw));
  return { c1: c1Text, c2: c2Text };
}

/* ========== UI Render ========== */
function displayResults(char1, char2, eval1, eval2, relScore, nerfed, buckets1, buckets2, finals1, finals2){
  const thumb = document.getElementById('score-thumb');
  const x = (relScore + 100)/2;
  thumb.style.left = `${x}%`;

  const scoreText = document.getElementById('score-text');
  const scoreComment = document.getElementById('score-comment');

  const who = relScore > 10 ? `${char2.name} 우세`
            : relScore < -10 ? `${char1.name} 우세` : '비슷함';
  scoreText.textContent = `${Math.round(relScore)}점 (${who})`;
  scoreComment.textContent = makeSummaryComment(relScore);

  document.getElementById('char1-result-name').textContent = `${char1.name} 분석`;
  document.getElementById('char2-result-name').textContent = `${char2.name} 분석`;
  document.getElementById('char1-nerfed-name').textContent = `${char1.name} 조정안`;
  document.getElementById('char2-nerfed-name').textContent = `${char2.name} 조정안`;

  renderAnalysis('char1-analysis', eval1, buckets1, true, finals1);
  renderAnalysis('char2-analysis', eval2, buckets2, false, finals2);

  document.getElementById('char1-nerfed').textContent = nerfed.c1 || '생성되지 않았습니다.';
  document.getElementById('char2-nerfed').textContent = nerfed.c2 || '생성되지 않았습니다.';

  resultsSection.classList.remove('hidden');
}

function renderAnalysis(targetId, evalMap, buckets, forA, finals){
  const el = document.getElementById(targetId);
  el.innerHTML = '';
  const ordered = [...BATTLE_CRITERIA, ...CRITERIA.filter(c=>!BATTLE_CRITERIA.includes(c))];

  for(const c of ordered){
    const raw = evalMap.get(c) || { score:50, comment:'-' };
    const row = document.createElement('div');
    row.className = 'crit-row';

    const name = document.createElement('div');
    name.className = 'crit-name text-sm text-gray-300';
    name.textContent = c;

    const barBox = document.createElement('div');
    barBox.className = 'flex-1';
    const barWrap = document.createElement('div');
    barWrap.className = 'progress-bar-container';
    const bar = document.createElement('div');
    bar.className = `progress-bar ${forA?'char1-bar':'char2-bar'}`;
    bar.style.width = `${Math.max(2, Math.min(100, raw.score))}%`;
    barWrap.appendChild(bar);

    const right = document.createElement('div');
    right.className = 'ml-3 text-right';
    const scoreSpan = document.createElement('div');
    scoreSpan.className = 'text-sm';
    scoreSpan.textContent = `${raw.score}`;

    const pill = document.createElement('div');
    pill.className = 'pill mt-1 text-gray-300';
    if(buckets[c]){
      pill.textContent = `${buckets[c].bucket}점 · ${buckets[c].text}`;
      pill.title = `self:${buckets[c].self} / opp:${buckets[c].opp}`;
    }else{
      pill.textContent = '참고 지표';
    }

    right.appendChild(scoreSpan);
    right.appendChild(pill);

    const comment = document.createElement('div');
    comment.className = 'w-full text-xs text-gray-400 mt-1';
    comment.textContent = raw.comment;

    barBox.appendChild(barWrap);
    row.appendChild(name);
    row.appendChild(barBox);
    row.appendChild(right);

    el.appendChild(row);
    el.appendChild(comment);
  }
}

function makeSummaryComment(rel){
  const v = Math.round(rel);
  if(v >= 60) return '캐릭터 2가 여러 분야에서 크게 우세합니다.';
  if(v >= 25) return '캐릭터 2가 우세합니다.';
  if(v > -25 && v < 25) return '두 캐릭터의 전력은 사실상 동등합니다.';
  if(v <= -60) return '캐릭터 1이 여러 분야에서 크게 우세합니다.';
  return '캐릭터 1이 우세합니다.';
}

/* 로딩 토글 */
function setLoading(on){
  analyzeBtn.disabled = on;
  loadingSpinner.classList.toggle('hidden', !on);
  btnText.textContent = on ? '분석 중...' : '강함 분석 및 밸런스 조정';
}
function setBattleLoading(on){
  battleBtn.disabled = on;
  battleLoading.classList.toggle('hidden', !on);
  battleBtnText.textContent = on ? '배틀 생성 중...' : '너프 적용 후 배틀 실행';
}
</script>
</body>
</html>
